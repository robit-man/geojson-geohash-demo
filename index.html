<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GeoJSON Globe — Terrain + Day/Night + Milky Way (Flip Switchboard)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three/build/three.module.js",
      "three/addons/": "https://unpkg.com/three/examples/jsm/"
    }
  }
  </script>

  <style>
    :root{ --bg:#0b1119; --fg:#eaf2ff; --muted:#9fb3c8; --accent:#66a6ff; --ok:#42d392; --warn:#f7b955; --bad:#ff6b6b; --panel:#0e1724; --border:#1b2a3c; }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,Segoe UI,Roboto,Arial}
    #app{position:fixed;inset:0}
    canvas{display:block}
    .panel{
      position:fixed; top:12px; left:12px; z-index:10; padding:12px; border-radius:12px;
      background:color-mix(in oklab, var(--panel) 86%, transparent);
      backdrop-filter: blur(8px); border:1px solid var(--border); max-width:min(92vw, 820px)
    }
    .panel h2{margin:0 0 8px 0; font-size:14px; font-weight:600; letter-spacing:.02em; color:var(--muted)}
    .row{display:flex; gap:8px; margin-bottom:8px; align-items:center; flex-wrap:wrap}
    .row label{font-size:12px; color:var(--muted)}
    .row input[type="text"], .row input[type="number"]{
      flex:1 1 120px; min-width:110px; padding:8px 10px; border-radius:10px; border:1px solid var(--border);
      background:#0a1220; color:var(--fg); outline:none;
    }
    .row input[type="text"]:focus, .row input[type="number"]:focus{border-color:#27486e}
    .row button{appearance:none; border:1px solid var(--border); background:#0c1828; color:var(--fg); padding:8px 12px; border-radius:10px; cursor:pointer;}
    .row button.primary{background:var(--accent); color:#031322; border-color:transparent; font-weight:600}
    .row button:active{transform:translateY(1px)}
    .help{font-size:12px; color:var(--muted)}
    .status{
      position:fixed; bottom:12px; left:12px; z-index:10; padding:8px 10px; border-radius:10px;
      background:color-mix(in oklab, var(--panel) 86%, transparent); border:1px solid var(--border);
      max-width:min(92vw,860px); white-space:pre-wrap
    }
    .legend{
      position:fixed; top:12px; right:12px; z-index:10; padding:8px 10px; border-radius:10px;
      background:color-mix(in oklab, var(--panel) 86%, transparent); border:1px solid var(--border);
      font-size:12px; color:var(--muted)
    }
    .inline{display:inline-flex; gap:8px; align-items:center}
    .sep{height:1px;background:var(--border);margin:8px 0}
    .flips{display:grid; grid-template-columns:auto repeat(2, minmax(34px, 48px)) repeat(2, minmax(34px, 48px)) repeat(2, minmax(34px, 48px)) repeat(2, minmax(34px, 48px)) repeat(2, minmax(34px, 48px)); gap:4px 10px; align-items:center}
    .flips .h{font-size:11px; color:var(--muted)}
    .flips label{font-size:12px; color:var(--muted)}
    .flips input{width:18px; height:18px}
    .badge{font-size:11px; color:#a6b8cc; border:1px solid var(--border); padding:2px 6px; border-radius:999px}
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="panel">
    <h2>GeoJSON Globe — Terrain-Draped + Day/Night + Milky Way</h2>

    <div class="row">
      <label for="gjurl">GeoJSON URL</label>
      <input id="gjurl" type="text" spellcheck="false" value="https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson" />
      <button id="load" class="primary">Load GeoJSON</button>
      <span class="inline" title="Toggle planet rotation">
        <input id="spin" type="checkbox"  />
        <label for="spin">Spin</label>
      </span>
      <span class="inline">
        <label for="tw">Twilight</label>
        <input id="tw" type="number" step="0.01" value="0.18" title="Terminator softness (0..1 in dot space)"/>
      </span>
      <span class="badge">Use the flips below and tell me which ones fix it.</span>
    </div>

    <div class="row">
      <label for="hmurl">Heightmap</label>
      <input id="hmurl" type="text" spellcheck="false" value="EARTH_DISPLACE_21K_16BITS.jpg" />
      <label for="subdiv">Subdiv</label>
      <input id="subdiv" type="number" min="5" max="128" step="1" value="128" title="Icosahedron subdivisions"/>
      <label for="hscale">Scale</label>
      <input id="hscale" type="number" step="0.001" value="0.028" title="Displacement scale (fraction of radius)"/>
      <label for="hbias">Bias</label>
      <input id="hbias" type="number" step="0.001" value="-0.014" title="Displacement bias (centers sea level)"/>
      <button id="loadHM">Load Heightmap</button>
    </div>

    <div class="sep"></div>

    <div class="row flips">
      <div></div>
      <div class="h">Disp U</div><div class="h">V</div>
      <div class="h">Day U</div><div class="h">V</div>
      <div class="h">Night U</div><div class="h">V</div>
      <div class="h">Cloud U</div><div class="h">V</div>
      <div class="h">Drape U</div><div class="h">V</div>

      <label>Flip signs</label>
      <input id="f-disp-u"  type="checkbox" /><input id="f-disp-v"  type="checkbox" checked/>
      <input id="f-day-u"   type="checkbox" /><input id="f-day-v"   type="checkbox" checked/>
      <input id="f-nt-u"    type="checkbox" /><input id="f-nt-v"    type="checkbox" checked/>
      <input id="f-cld-u"   type="checkbox" checked/><input id="f-cld-v"   type="checkbox" checked/>
      <input id="f-drape-u" type="checkbox" checked /><input id="f-drape-v" type="checkbox" />
    </div>

    <div class="sep"></div>

    <div class="row">
      <label for="geohash">Geohash</label>
      <input id="geohash" type="text" placeholder="e.g. 9q8yyxk6p" />
    </div>
    <div class="row">
      <label for="lat">Lat</label>
      <input id="lat" type="number" step="any" placeholder="e.g. 37.7749" />
      <label for="lon">Lon</label>
      <input id="lon" type="number" step="any" placeholder="-122.4194" />
      <label for="len">Line len</label>
      <input id="len" type="number" step="0.1" value="0.6" title="Probe length in radii"/>
      <button id="plot" class="primary">Plot</button>
      <button id="clear">Clear</button>
    </div>

    <div class="help">Flip U/V per-layer to diagnose orientation. Spin can be turned off from the checkbox.</div>
  </div>

  <div class="legend">Mouse: drag to orbit • wheel to zoom • right-drag to pan • click globe to select</div>
  <div class="status" id="status">Ready.</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ---------- Constants ----------
    const UV_YAW = 0.5; // 180° yaw so Greenwich is in the middle

    // ---------- Scene ----------
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.01, 2000);
    camera.position.set(0, 0.9, 2.2);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const hemi = new THREE.HemisphereLight(0xc0d8ff, 0x101822, 0.45); scene.add(hemi);
    const dir  = new THREE.DirectionalLight(0xffffff, 0.7); dir.position.set(2,2,2); scene.add(dir);

    // ---------- Background ----------
    const loader = new THREE.TextureLoader(); loader.setCrossOrigin('anonymous');
    loader.load('8k_stars_milky_way.jpg', (tex)=>{ tex.mapping = THREE.EquirectangularReflectionMapping; tex.colorSpace = THREE.SRGBColorSpace; scene.background = tex; });

    // ---------- Groups ----------
    const planet = new THREE.Group(); scene.add(planet);
    const R = 1.0;
    const globe = new THREE.Mesh(new THREE.SphereGeometry(R, 96, 64), new THREE.MeshBasicMaterial({ visible:false }));
    planet.add(globe);

    // Layers
    let heightMesh = null, cloudsMesh = null;
    const geoLayer = new THREE.Group(), probeLayer = new THREE.Group();
    planet.add(geoLayer, probeLayer);

    // ---------- DOM ----------
    const $ = s => document.querySelector(s);
    const status = $('#status');
    const gjurl = $('#gjurl'), loadBtn = $('#load');
    const hmurl = $('#hmurl'), loadHMBtn = $('#loadHM');
    const subdivIn = $('#subdiv'), hscaleIn = $('#hscale'), hbiasIn = $('#hbias');
    const ghIn = $('#geohash'), latIn = $('#lat'), lonIn = $('#lon'), lenIn = $('#len');
    const plotBtn = $('#plot'), clearBtn = $('#clear'), spinChk = $('#spin'), twilightIn = $('#tw');

    // Flip checkboxes
    const fDispU = $('#f-disp-u'),  fDispV = $('#f-disp-v');
    const fDayU  = $('#f-day-u'),   fDayV  = $('#f-day-v');
    const fNtU   = $('#f-nt-u'),    fNtV   = $('#f-nt-v');
    const fCldU  = $('#f-cld-u'),   fCldV  = $('#f-cld-v');
    const fDrU   = $('#f-drape-u'), fDrV   = $('#f-drape-v');

    function setStatus(msg, tone=''){ status.textContent = msg; status.style.borderColor = ({ok:'var(--ok)',warn:'var(--warn)',bad:'var(--bad)'}[tone]) || 'var(--border)'; }

    // ---------- Math ----------
    function toRad(d){ return d * Math.PI/180; }
    function toDeg(r){ return r * 180/Math.PI; }
    function llToVec3(latDeg, lonDeg, r=R){
      const phi = toRad(90 - latDeg);
      const theta = toRad(lonDeg + 180);
      const x = -r * Math.sin(phi) * Math.cos(theta);
      const z =  r * Math.sin(phi) * Math.sin(theta);
      const y =  r * Math.cos(phi);
      return new THREE.Vector3(x,y,z);
    }
    function vec3ToLL(pLocal){
      const n = pLocal.clone().normalize();
      const phi = Math.acos(THREE.MathUtils.clamp(n.y, -1, 1));
      const lat = 90 - toDeg(phi);
      const theta = Math.atan2(n.z, -n.x);
      let lon = toDeg(theta) - 180;
      lon = ((lon + 540) % 360) - 180;
      return { lat, lon };
    }

    // ---------- Sun model (UTC → subsolar) ----------
    function subsolarLongitudeUTC(date){ const ut = date.getUTCHours() + date.getUTCMinutes()/60 + date.getUTCSeconds()/3600; let lon = -15 * (ut - 12); return ((lon + 540) % 360) - 180; }
    function subsolarLatitudeUTC(date){
      const start = Date.UTC(date.getUTCFullYear(), 0, 0);
      const N = Math.floor((date - start) / 86400000);
      const g = 2*Math.PI*(N-1)/365;
      const d = 0.006918 - 0.399912*Math.cos(g) + 0.070257*Math.sin(g) - 0.006758*Math.cos(2*g) + 0.000907*Math.sin(2*g) - 0.002697*Math.cos(3*g) + 0.00148*Math.sin(3*g);
      return d * 180/Math.PI;
    }
    function sunDirWorld(date=new Date()){ return llToVec3(subsolarLatitudeUTC(date), subsolarLongitudeUTC(date), 1.0).normalize(); }

    // ---------- CPU sampler (for drape & probes) ----------
    let sampler = { ready:false, data:null, w:0, h:0, uOffset: UV_YAW, scaleR:0.128*R, biasR:-0.014*R, baseRadius:R*1.0008 };
    let drapeFlipU=false, drapeFlipV=false;

    function buildSamplerFromImage(img, scale, bias){
      const can = document.createElement('canvas'), ctx = can.getContext('2d', { willReadFrequently:true });
      can.width = img.naturalWidth || img.width; can.height = img.naturalHeight || img.height;
      ctx.drawImage(img, 0, 0, can.width, can.height);
      const id = ctx.getImageData(0, 0, can.width, can.height);
      sampler.data = id.data; sampler.w = can.width; sampler.h = can.height;
      sampler.scaleR = scale * R; sampler.biasR = bias * R; sampler.ready = true;
    }
    function sampleHeightUV(u, v){
      if(!sampler.ready || !sampler.data) return 0.0;
      // Apply yaw then drape flips (canvas origin: v=0 is top)
      u = (u + sampler.uOffset) % 1; if(u<0) u+=1;
      if(drapeFlipU) u = 1 - u;
      if(drapeFlipV) v = 1 - v;
      v = THREE.MathUtils.clamp(v, 0, 1);
      const x = Math.min(sampler.w - 1, Math.max(0, Math.floor(u * sampler.w)));
      const y = Math.min(sampler.h - 1, Math.max(0, Math.floor(v * sampler.h)));
      const i = (y * sampler.w + x) * 4;
      return sampler.data[i] / 255.0; // red
    }
    function radiusAtLL(lat, lon){
      const u = (lon + 180) / 360;
      const v = (90 - lat) / 180; // north at top
      const h = sampleHeightUV(u, v);
      return sampler.baseRadius + sampler.biasR + sampler.scaleR * h;
    }

    // ---------- Earth material (manual day/night) ----------
    let earthUniformsRef = null;
    let dispTexRef = null, dayTexRef = null, nightTexRef = null, cloudsTexRef = null;

    function buildEarthMaterial(dayTex, nightTex, dispTex, scale, bias){
      const mat = new THREE.MeshStandardMaterial({
        color: 0xffffff, roughness: 1.0, metalness: 0.0,
        displacementMap: dispTex, displacementScale: scale * R, displacementBias: bias * R
      });

      mat.onBeforeCompile = (shader)=>{
        shader.uniforms.dayMap   = { value: dayTex };
        shader.uniforms.nightMap = { value: nightTex };
        shader.uniforms.sunDir   = { value: sunDirWorld() };
        shader.uniforms.twilight = { value: parseFloat(twilightIn.value) || 0.18 };
        shader.uniforms.uYaw     = { value: UV_YAW };
        // Per-layer flip uniforms (0/1)
        shader.uniforms.flipDay  = { value: new THREE.Vector2(0,0) };
        shader.uniforms.flipNt   = { value: new THREE.Vector2(0,0) };

        shader.vertexShader =
          'varying vec3 vWorldNormal;\n' +
          shader.vertexShader.replace('#include <beginnormal_vertex>',
            `#include <beginnormal_vertex>
             vWorldNormal = normalize( (modelMatrix * vec4(objectNormal, 0.0)).xyz );`);

        shader.fragmentShader =
          `
          uniform sampler2D dayMap, nightMap;
          uniform vec3  sunDir;
          uniform float twilight, uYaw;
          uniform vec2  flipDay, flipNt;
          varying vec3  vWorldNormal;
          #ifndef texture2D
          #define texture2D texture
          #endif
          ` + shader.fragmentShader.replace('#include <color_fragment>',
            `
            {
              vec3 n = normalize(vWorldNormal);

              float c = dot(n, normalize(sunDir));
              float t = smoothstep(-twilight, twilight, c);

              float u = (atan(n.z, -n.x) + 3.141592653589793) / 6.283185307179586;
              u = fract(u + uYaw);
              float v = 1.0 - (acos(clamp(n.y, -1.0, 1.0)) / 3.141592653589793);

              vec2 uvD = vec2(flipDay.x > 0.5 ? 1.0-u : u, flipDay.y > 0.5 ? 1.0-v : v);
              vec2 uvN = vec2(flipNt.x  > 0.5 ? 1.0-u : u, flipNt.y  > 0.5 ? 1.0-v : v);

              vec3 dayRGB   = texture2D(dayMap,   uvD).rgb;
              vec3 nightRGB = texture2D(nightMap, uvN).rgb;
              vec3 base     = mix(nightRGB, dayRGB, t);

              diffuseColor = vec4(base, 1.0);
              diffuseColor.rgb += (1.0 - t) * nightRGB * 0.12;
            }
            `
          );

        earthUniformsRef = shader.uniforms;
      };

      mat.needsUpdate = true;
      return mat;
    }

    // ---------- Texture helpers ----------
    function loadTex(path, { srgb=true, repeat=true, anisotropy=true, flipY=false } = {}){
      return new Promise((resolve, reject)=>{
        loader.load(path, (tex)=>{
          tex.colorSpace = srgb ? THREE.SRGBColorSpace : THREE.LinearSRGBColorSpace;
          tex.wrapS = tex.wrapT = repeat ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
          tex.flipY = flipY; tex.needsUpdate = true;
          if (anisotropy && renderer.capabilities.getMaxAnisotropy) tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
          resolve(tex);
        }, undefined, reject);
      });
    }
    function applyTexFlip(tex, flipU, flipV){
      if(!tex) return;
      tex.repeat.set(flipU ? -1 : 1, flipV ? -1 : 1);
      tex.offset.set(flipU ? 1 : 0, flipV ? 1 : 0);
      tex.needsUpdate = true;
    }

    function addEquirectUVs(geometry){
      const pos = geometry.attributes.position;
      const uv  = new Float32Array(pos.count * 2);
      const p   = new THREE.Vector3();
      for(let i=0;i<pos.count;i++){
        p.fromBufferAttribute(pos, i).normalize();
        let u = (Math.atan2(p.z, -p.x) + Math.PI) / (2*Math.PI);
        u = (u + UV_YAW) % 1;
        const v = 1.0 - (Math.acos(THREE.MathUtils.clamp(p.y, -1, 1)) / Math.PI);
        uv[i*2+0] = u; uv[i*2+1] = v;
      }
      geometry.setAttribute('uv', new THREE.BufferAttribute(uv, 2));
    }

    // Preload (flipY=false; we control vertical in code)
    const dayTexP   = loadTex('8k_earth_daymap.jpg',   { srgb:true,  repeat:true, flipY:false });
    const nightTexP = loadTex('8k_earth_nightmap.jpg', { srgb:true,  repeat:true, flipY:false });

    // ---------- Build Earth ----------
    async function loadHeightOverlay(url, subdiv=64, scale=0.128, bias=-0.014){
      setStatus('Loading heightmap + Earth textures…');
      try{
        dispTexRef = await new Promise((resolve, reject)=> loader.load(url, (t)=>{
          t.generateMipmaps = true; t.minFilter = THREE.LinearMipmapLinearFilter; t.magFilter = THREE.LinearFilter;
          t.wrapS = t.wrapT = THREE.RepeatWrapping; t.flipY = false; t.colorSpace = THREE.LinearSRGBColorSpace; t.needsUpdate = true;
          resolve(t);
        }, undefined, reject));

        [dayTexRef, nightTexRef] = await Promise.all([dayTexP, nightTexP]);

        // Rebuild mesh
        if(heightMesh){ heightMesh.geometry.dispose(); heightMesh.material?.dispose?.(); planet.remove(heightMesh); heightMesh=null; }
        sampler.baseRadius = R * 1.0008;

        const detail = Math.max(1, Math.min(128, parseInt(subdiv,10)||64));
        const geom = new THREE.IcosahedronGeometry(sampler.baseRadius, detail);
        addEquirectUVs(geom);

        const mat = buildEarthMaterial(dayTexRef, nightTexRef, dispTexRef, scale, bias);
        heightMesh = new THREE.Mesh(geom, mat);
        heightMesh.frustumCulled = true; planet.add(heightMesh);

        buildSamplerFromImage(dispTexRef.image, scale, bias);
        sampler.uOffset = UV_YAW;

        await ensureCloudsShell();
        if(lastGeoJSON) drawGeoJSON(lastGeoJSON);

        // Apply current flip switches
        applyDispFlip(); applyShaderFlips(); applyCloudsFlip(); // drape flip is used at sample time
        setStatus(`Earth ready (detail=${detail}, scale=${scale}, bias=${bias})`, 'ok');
      }catch(err){ console.error(err); setStatus('Failed to build Earth: ' + (err?.message || err), 'bad'); }
    }

    async function ensureCloudsShell(){
      if(cloudsMesh){ cloudsMesh.geometry.dispose(); cloudsMesh.material?.map?.dispose?.(); cloudsMesh.material?.dispose?.(); planet.remove(cloudsMesh); cloudsMesh=null; }
      cloudsTexRef = await loadTex('8k_earth_clouds.jpg', { srgb:true, repeat:true, flipY:false });
      const g = new THREE.SphereGeometry(sampler.baseRadius * 1.003, 96, 64);
      addEquirectUVs(g);
      const m = new THREE.MeshStandardMaterial({ map: cloudsTexRef, transparent:true, opacity:0.35, roughness:1.0, metalness:0.0, depthWrite:false });
      cloudsMesh = new THREE.Mesh(g, m); cloudsMesh.renderOrder = 3; planet.add(cloudsMesh);
    }

    // ---------- GeoJSON (draped) ----------
    let lastGeoJSON = null;

    async function loadGeoJSON(url){
      setStatus('Loading GeoJSON…');
      try{
        const res = await fetch(url, { mode:'cors' });
        if(!res.ok) throw new Error(res.status+' '+res.statusText);
        lastGeoJSON = await res.json();
        drawGeoJSON(lastGeoJSON);
        setStatus('GeoJSON loaded.', 'ok');
      }catch(err){ console.error(err); setStatus('Failed to load GeoJSON: ' + (err?.message || err), 'bad'); }
    }

    function clearGroup(g){
      for(let i=g.children.length-1;i>=0;i--){
        const o=g.children[i];
        o.geometry?.dispose?.();
        if(o.material){ Array.isArray(o.material) ? o.material.forEach(m=>m.dispose?.()) : o.material.dispose?.(); }
        g.remove(o);
      }
    }

    function densifyLonLat(path, maxDeg=2){
      if(path.length < 2) return path.map(([lon,lat])=>({lat,lon}));
      const out = [];
      for(let i=0;i<path.length-1;i++){
        let [lon1, lat1] = path[i], [lon2, lat2] = path[i+1];
        let dlon = ((lon2 - lon1 + 540) % 360) - 180;
        const dlat = (lat2 - lat1);
        const steps = Math.max(1, Math.ceil(Math.max(Math.abs(dlon), Math.abs(dlat)) / maxDeg));
        for(let s=0;s<steps;s++){ const t = s/steps; out.push({lat: lat1 + dlat*t, lon: lon1 + dlon*t}); }
      }
      const [lonF, latF] = path[path.length-1]; out.push({lat:latF, lon:lonF});
      return out;
    }

    function drapedPoint(lat, lon, lift=0.0015){
      const r = sampler.ready ? radiusAtLL(lat, lon) + lift : R * 1.0012;
      return llToVec3(lat, lon, r);
    }

    function drawGeoJSON(gj){
      clearGroup(geoLayer);
      const matCoast = new THREE.LineBasicMaterial({ color: 0x84c5ff, transparent:true, opacity: 0.96, depthWrite:false });
      const matInner = new THREE.LineBasicMaterial({ color: 0x3aa0ff, transparent:true, opacity: 0.45, depthWrite:false });
      geoLayer.renderOrder = 4;

      const LIFT = 0.0015;
      const asLines = (rings, isOuter) => {
        rings.forEach((ring) => {
          const dense = densifyLonLat(ring);
          const pts = dense.map(p => drapedPoint(p.lat, p.lon, LIFT));
          if(pts.length>2) pts.push(pts[0].clone());
          const geo = new THREE.BufferGeometry().setFromPoints(pts);
          geoLayer.add(new THREE.Line(geo, isOuter ? matCoast : matInner));
        });
      };
      const walk = (geom) => {
        if(!geom) return;
        if(geom.type === 'Polygon'){
          const rings = geom.coordinates.map(r => r.map(([lon,lat])=>[lon,lat]));
          if(rings.length) asLines([rings[0]], true);
          if(rings.length>1) asLines(rings.slice(1), false);
        } else if (geom.type === 'MultiPolygon'){
          geom.coordinates.forEach(poly=>{
            const rings = poly.map(r => r.map(([lon,lat])=>[lon,lat]));
            if(rings.length) asLines([rings[0]], true);
            if(rings.length>1) asLines(rings.slice(1), false);
          });
        } else if (geom.type === 'LineString'){
          const dense = densifyLonLat(geom.coordinates.map(([lon,lat])=>[lon,lat]));
          const pts = dense.map(p => drapedPoint(p.lat, p.lon, LIFT));
          geoLayer.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), matCoast));
        } else if (geom.type === 'MultiLineString'){
          geom.coordinates.forEach(line=>{
            const dense = densifyLonLat(line.map(([lon,lat])=>[lon,lat]));
            const pts = dense.map(p => drapedPoint(p.lat, p.lon, LIFT));
            geoLayer.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), matCoast));
          });
        } else if (geom.type === 'GeometryCollection'){
          (geom.geometries||[]).forEach(walk);
        }
      };

      if(gj.type === 'FeatureCollection'){ (gj.features||[]).forEach(f=>walk(f.geometry)); }
      else if (gj.type === 'Feature'){ walk(gj.geometry); }
      else { walk(gj); }
    }

    // ---------- Probes ----------
    function decodeGeohash(gh){
      const base32 = '0123456789bcdefghjkmnpqrstuvwxyz';
      let even=true, lat=[-90,90], lon=[-180,180], latErr=90, lonErr=180;
      for(const ch of (gh||'').toLowerCase()){
        const cd = base32.indexOf(ch); if(cd===-1) continue;
        for(let mask=16; mask>0; mask>>=1){
          if(even){ lonErr/=2; (cd&mask)? (lon[0]=(lon[0]+lon[1])/2) : (lon[1]=(lon[0]+lon[1])/2); }
          else    { latErr/=2; (cd&mask)? (lat[0]=(lat[0]+lat[1])/2) : (lat[1]=(lat[0]+lat[1])/2); }
          even=!even;
        }
      }
      return { lat:(lat[0]+lat[1])/2, lon:(lon[0]+lon[1])/2, latErr, lonErr };
    }
    function encodeGeohash(lat, lon, precision=9){
      const base32 = '0123456789bcdefghjkmnpqrstuvwxyz';
      let even=true, latR=[-90,90], lonR=[-180,180], bits=[16,8,4,2,1], ch=0, bit=0, hash='';
      for(let i=0;i<precision;){
        if(even){ const mid=(lonR[0]+lonR[1])/2; if(lon>=mid){ch|=bits[bit]; lonR[0]=mid;} else lonR[1]=mid; }
        else    { const mid=(latR[0]+latR[1])/2; if(lat>=mid){ch|=bits[bit]; latR[0]=mid;} else latR[1]=mid; }
        even=!even; if(bit<4){bit++;} else {hash+=base32[ch]; i++; ch=0; bit=0;}
      }
      return hash;
    }
    function plotProbeAt(lat, lon, length=0.6){
      if(!isFinite(lat) || !isFinite(lon)){ setStatus('Invalid lat/lon.', 'bad'); return; }
      lat = Math.max(-90, Math.min(90, lat)); lon = ((lon + 540) % 360) - 180;
      const r0 = sampler.ready ? radiusAtLL(lat, lon) : R*1.002;
      const base = llToVec3(lat, lon, r0), dir = base.clone().normalize(), tip = base.clone().addScaledVector(dir, length);
      const g = new THREE.BufferGeometry().setFromPoints([base, tip]);
      const line = new THREE.Line(g, new THREE.LineBasicMaterial({ color: 0xffe066 }));
      const tipMesh = new THREE.Mesh(new THREE.SphereGeometry(0.01, 16, 12), new THREE.MeshStandardMaterial({ color: 0xffe066, emissive: 0x332100 }));
      tipMesh.position.copy(tip);
      const ring = new THREE.Mesh(new THREE.RingGeometry(0.010, 0.014, 32), new THREE.MeshBasicMaterial({ color: 0xffe066, transparent:true, opacity:0.7, side:THREE.DoubleSide }));
      const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), dir);
      ring.quaternion.copy(q); ring.position.copy(base);
      probeLayer.add(line, tipMesh, ring);
      setStatus(`Plotted @ lat ${lat.toFixed(6)}, lon ${lon.toFixed(6)}`, 'ok');
    }

    // ---------- UI wiring ----------
    loadBtn.addEventListener('click', ()=> loadGeoJSON(gjurl.value.trim()));
    loadHMBtn.addEventListener('click', ()=> loadHeightOverlay(hmurl.value.trim(), parseInt(subdivIn.value,10), parseFloat(hscaleIn.value), parseFloat(hbiasIn.value)));
    twilightIn.addEventListener('change', ()=>{ if(earthUniformsRef){ earthUniformsRef.twilight.value = parseFloat(twilightIn.value) || 0.18; }});
    plotBtn.addEventListener('click', ()=>{
      const gh = ghIn.value.trim();
      let lat = parseFloat(latIn.value), lon = parseFloat(lonIn.value);
      if(gh){ const dec = decodeGeohash(gh); lat=dec.lat; lon=dec.lon; }
      plotProbeAt(lat, lon, parseFloat(lenIn.value)||0.6);
    });
    clearBtn.addEventListener('click', ()=>{ clearGroup(probeLayer); setStatus('Cleared probes.'); });
    [ghIn,latIn,lonIn,lenIn,subdivIn,hscaleIn,hbiasIn].forEach(inp=>inp.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); plotBtn.click(); }}));

    // Flip handlers
    function applyDispFlip(){ applyTexFlip(dispTexRef, fDispU.checked, fDispV.checked); }
    function applyCloudsFlip(){ if(cloudsTexRef){ applyTexFlip(cloudsTexRef, fCldU.checked, fCldV.checked); } }
    function applyShaderFlips(){
      if(!earthUniformsRef) return;
      earthUniformsRef.flipDay.value.set( fDayU.checked ? 1:0, fDayV.checked ? 1:0 );
      earthUniformsRef.flipNt.value.set(  fNtU.checked  ? 1:0, fNtV.checked  ? 1:0 );
    }
    function applyDrapeFlip(){ drapeFlipU = fDrU.checked; drapeFlipV = fDrV.checked; if(lastGeoJSON) drawGeoJSON(lastGeoJSON); }

    [fDispU,fDispV].forEach(el=>el.addEventListener('change', applyDispFlip));
    [fCldU,fCldV].forEach(el=>el.addEventListener('change', applyCloudsFlip));
    [fDayU,fDayV,fNtU,fNtV].forEach(el=>el.addEventListener('change', applyShaderFlips));
    [fDrU,fDrV].forEach(el=>el.addEventListener('change', applyDrapeFlip));

    // ---------- Picking ----------
    const raycaster = new THREE.Raycaster(); const ndc = new THREE.Vector2(); let down = null;
    const pickTargets = ()=> heightMesh ? [heightMesh, globe] : [globe];
    function pointerToNDC(e){ const rect = renderer.domElement.getBoundingClientRect(); ndc.x = ((e.clientX - rect.left) / rect.width) * 2 - 1; ndc.y = -((e.clientY - rect.top) / rect.height) * 2 + 1; }
    renderer.domElement.addEventListener('pointerdown', (e)=>{ if(e.button!==0) return; down = {x:e.clientX, y:e.clientY}; });
    renderer.domElement.addEventListener('pointerup', (e)=>{
      if(e.button!==0) return; if(!down) return;
      const moved = Math.hypot(e.clientX - down.x, e.clientY - down.y); down = null; if(moved>5) return;
      pointerToNDC(e); raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(pickTargets(), true); if(!hits.length) return;
      const worldPoint = hits[0].point.clone(), center = planet.getWorldPosition(new THREE.Vector3());
      const dir = worldPoint.sub(center).normalize(), pLocal = dir.clone();
      const { lat, lon } = vec3ToLL(pLocal);
      latIn.value = lat.toFixed(6); lonIn.value = lon.toFixed(6);
      const prec = Math.max(1, Math.min(12, (ghIn.value.trim().length || 9))); ghIn.value = encodeGeohash(lat, lon, prec);
      setStatus(`Picked @ lat ${lat.toFixed(6)}, lon ${lon.toFixed(6)} • geohash ${ghIn.value}`, 'ok');
    });

    // ---------- Run ----------
    let spinning = false;
    spinChk.addEventListener('change', ()=> { spinning = spinChk.checked; });
    function onResize(){ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }
    addEventListener('resize', onResize);

    // Defaults
    loadGeoJSON(gjurl.value.trim());
    loadHeightOverlay(hmurl.value.trim(), parseInt(subdivIn.value,10), parseFloat(hscaleIn.value), parseFloat(hbiasIn.value));

    setInterval(()=>{ if(earthUniformsRef){ earthUniformsRef.sunDir.value.copy(sunDirWorld()); earthUniformsRef.twilight.value = parseFloat(twilightIn.value) || 0.18; }}, 1000);

    (function loop(){
      requestAnimationFrame(loop);
      if(spinning){ planet.rotation.y += 0.0032; }
      if(cloudsMesh){ cloudsMesh.rotation.y += 0.00035; }
      controls.update(); renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
